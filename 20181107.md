# SolidityNote
solidity语言学习心得笔记

* 合约结构<br>
  * 状态变量
```solidity
prama solidity ^0.4.0;
contract SimpleStorage{
    uint storedData;  //状态变量
    //...
}
```
  * 函数<br>
    函数是合约中代码的可执行单元
```solidity
contract SimpleAuction{
    function bid() public payable{ //函数
        //...
    }
}
```
  * 函数修饰器<br>
函数修饰器可以用来以声明的方式改良函数语义<br>
```solidity
contract Purchase{
    address public seller;
    modifier onlySeller(){   //修饰器
        require(
            msg.sender == seller,
            "Only seller can call this."
        );
        _;
    }
    
    function  abort() public onlySeller{    //Modifier usage
        //...
    }
}
```
  * 事件<br>
事件是能方便地调用以太坊虚拟机日志功能的接口<br>
```solidity
contract SimpleAuction{
    event HighestBidIncreased(address bidder,uint amount); //事件
    function bid()  public payable {
        //...
        emit HighestBidIncreased(msg.send,msg.value); //触发事件
    }
}
```
  * 结构类型<br>
```solidity
contract Ballot{
    struct Voter{  //结构体
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
}
```
  * 枚举类型<br>
枚举可用来创建由一定数量的“常量值”构成的自定义类型
```solidity
contract Purchase{
    enum State { Created, Locked , Inactive } //枚举
}
```


　　（以下从一点一点地分析Solidity）<br>
## * 类型
 与c++中的类型基本一致，注：Solidity不完全支持定长浮点型。可以声明定长浮点型的变量，但不能赋值。<br>
 ### * 地址类型<br>
address：地址类型存储一个20字节的值（以太坊地址的大小）。地址类型也有成员变量，并作为所有合约的基础。<br>

运算符：
* `<=`,`<`,`==`,`!=`,`>=`和`>`<br>
#### * 地址类型成员变量
* `balance` 和 `transfer`

可以使用`balance`属性来查询一个地址的余额，也可以使用`transfer`函数向一个地址发送以太币（以wei为单位）：<br>
  如果 x 是一个合约地址，它的代码（更具体来说是它的 fallback 函数，如果有的话）会跟 transfer 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。如   果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。<br>
* `send`
`send`是 `transfer`的低级版本。如果执行失败，当前的合约不会因为异常而终止，但`send`会返回`false`。<br>
* 警告
  在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证   以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用一种接收者可以取回资金的模式。<br>
* `call`, `callcode` 和 `delegatecall`
这3个函数的用法类型，都可以用他们来调用智能合约或函数，例如：<br>
```solidity
address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;
nameReg.call("register","MyName");
nameReg.call(bytes4(keccak256("fun(uint256)")), a);
```
  
  
可以使用 .gas() 修饰器modifier 调整提供的 gas 数量
```solidity
nameReg.call.gas(1000000)("register","MyName");
```
类似地，也能控制提供的以太币的值：<br>
```solidity
nameReg.call.value(1 ether)("register","MyName");
```
最后，这些修饰器（modifier）可以联合使用。每个修改器出现的顺序不重要
```
nameReg.call.gas(1000000).value(1 ether)("register","MyName");
```
call 返回的布尔值表明了被调用的函数已经执行完毕（true）或者引发了一个 EVM 异常（false）。 无法访问返回的真实数据（为此我们需要事先知道编码和大      小）。<br>
  类似地，也可以使用 delegatecall： 区别在于只使用给定地址的代码，其它属性（存储，余额，……）都取自当前合约。 delegatecall 的目的是使用存储在另外一    个合约中的库代码。 用户必须确保两个合约中的存储结构都适用于 delegatecall。 在 homestead 版本之前，只有一个功能类似但作用有限的 callcode 的函数    可用，但它不能获取委托方的 msg.sender 和 msg.value。<br>
注：当使用call调用其它合约的函数时，代码是在被调用的合约的环境里执行，对应的，使用delegatecall进行函数调用时代码则是在调用函数的环境里执行<br>
这三个函数 call， delegatecall 和 callcode 都是非常低级的函数，应该只把它们当作 最后一招 来使用，因为它们破坏了 Solidity 的类型安全性
* 定长字节数组
关键字有：bytes1，bytes2，bytes3，...,bytes32。byte是bytes1的别名<br>
* 变长字节数组：
bytes和string
### * 函数类型
函数类型分为内部函数和外部函数。<br>

  内部函数只能在当前合约内被调用（更具体来说，在当前代码块内，包括内部库函数和继承的函数中），因为它们不能在当前合约上下文的外部被执行。 调用一个内部   函数是通过跳转到它的入口标签来实现的，就像在当前合约的内部调用一个函数。<br>

外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。

### * 引用类型
* 数据位置
  在`数组`和`结构`类型中，都有一个额外的属性，“数据位置”，说明数据是保存在memory还是在storage中。 函数参数（包括返回的参数）的数据位置默认是          memory， 局部变量的数据位置默认是 storage，状态变量的数据位置强制是 storage 。<br>
  
  数据位置的指定非常重要，在storage和memory之间两两赋值，或者storage向状态变量赋值都会创建一份独立的拷贝。但状态变量向storage赋值时仅仅传递一个引   用。另一方面，从一个memory存储的引用类型向另一个memory存储的引用类型赋值并不会创建拷贝。

### * 单元和全局变量
* 特殊变量和函数

* 区块和交易属性

  
